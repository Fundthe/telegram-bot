import os
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    ContextTypes, ConversationHandler, filters, CallbackQueryHandler
)
from flask import Flask
from threading import Thread

# --- Keep Alive ---
app_web = Flask('')

@app_web.route('/')
def home():
    return "I'm alive!"

def run():
    app_web.run(host='0.0.0.0', port=8080)

def keep_alive():
    t = Thread(target=run)
    t.start()

# --- Telegram bot ---
load_dotenv()

CHOOSING, RATE, HOURS, LOOP_TOKENS, LOOP_LTV, LOOP_SUPPLY, LOOP_BORROW, \
LOAN_DEP_AMOUNT, LOAN_DEP_PRICE, LOAN_BORROW_AMOUNT, LOAN_BORROW_PRICE, \
LOAN_LTV, LOAN_BORROW_FACTOR, IL_INPUT, IL_FEES = range(15)

user_data_temp = {}

def calculate_simple(rate, hours):
    periods = 8760 / hours  # —á–∞—Å–æ–≤ –≤ –≥–æ–¥—É
    return rate * periods

def calculate_looping_table(tokens, ltv, supply_rate, borrow_rate):
    rounds = []
    deposit = tokens
    total_borrow = 0

    for i in range(1, 11):
        borrow = deposit * ltv
        total_borrow += borrow
        deposit += borrow
        net_apy = (deposit * supply_rate - total_borrow * borrow_rate) / tokens
        rounds.append({
            'round': i,
            'deposit': deposit,
            'borrow': borrow,
            'total_borrow': total_borrow,
            'apy': net_apy
        })

    return rounds

def back_to_menu_button():
    return InlineKeyboardMarkup([[InlineKeyboardButton("üîô –í –Ω–∞—á–∞–ª–æ", callback_data="back")]])

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìà –°—Ç–∞–≤–∫–∞ —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è", callback_data="rate"),
         InlineKeyboardButton("üîÅ –õ—É–ø–∏–Ω–≥", callback_data="looping")],
        [InlineKeyboardButton("üí≥ –ö—Ä–µ–¥–∏—Ç–æ–≤–∞–Ω–∏–µ", callback_data="loan"),
         InlineKeyboardButton("üìâ Impermanent Loss", callback_data="il")]
    ])
    if update.message:
        await update.message.reply_markdown_v2("*üìã–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞*", reply_markup=keyboard)
    elif update.callback_query:
        await update.callback_query.message.edit_text("üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n\nüîΩ –í—ã–±–µ—Ä–∏ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:", reply_markup=keyboard)
    return CHOOSING
    
async def get_rate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        rate = float(update.message.text.strip().replace('%', ''))
        user_data_temp[update.effective_chat.id] = {'rate': rate}
        await update.message.reply_text("‚è± –¢–µ–ø–µ—Ä—å –Ω–∞–ø–∏—à–∏, —Ä–∞–∑ –≤ —Å–∫–æ–ª—å–∫–æ —á–∞—Å–æ–≤ –Ω–∞—á–∏—Å–ª—è–µ—Ç—Å—è –ø—Ä–æ—Ü–µ–Ω—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä: 4)")
        return HOURS
    except ValueError:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ —á–∏—Å–ª–æ. –ù–∞–ø—Ä–∏–º–µ—Ä: 0.5")
        return RATE
        
async def get_hours(update: Update, context: ContextTypes.DEFAULT_TYPE):
            try:
                hours = float(update.message.text.strip().replace('—á', '').replace(' ', ''))
                rate = user_data_temp.get(update.effective_chat.id, {}).get('rate')

                if rate is None:
                    await update.message.reply_text("‚ùå –°—Ç–∞–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏ —Å–Ω–∞—á–∞–ª–∞.")
                    return await start(update, context)

                simple = calculate_simple(rate, hours)

                response = (
                    "*üìà –†–∞—Å—á—ë—Ç —Ñ–∞–Ω–¥–∏–Ω–≥–∞*\n"
                    "```\n"
                    f"{'–°—Ç–∞–≤–∫–∞ —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è:':<22} {rate}%\n"
                    f"{'–ù–∞—á–∏—Å–ª—è–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ:':<22} {hours} —á\n"
                    f"{'APR:':<22} {simple:.2f}%\n"
                    "```")

                await update.message.reply_markdown_v2(response)
                return await start(update, context)

            except Exception:
                await update.message.reply_text("‚ùå –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
                return RATE
                
async def get_il_fees(update: Update, context: ContextTypes.DEFAULT_TYPE):
            chat_id = update.effective_chat.id
            text = update.message.text.strip().replace(',', '.')
            user_state = user_data_temp.get(chat_id, {})

            try:
                fee_pct = float(text)
                investment = 1000
                half = investment / 2

                p1_initial = user_state['p1_initial']
                p1_now = user_state['p1_now']
                p2_initial = user_state['p2_initial']
                p2_now = user_state['p2_now']

                r1 = p1_now / p1_initial
                r2 = p2_now / p2_initial
                k = r1 / r2
                il = (2 * (k ** 0.5) / (1 + k)) - 1

                hodl_value = half * r1 + half * r2

                sqrt_k = k ** 0.5
                pool_token1 = (half / p1_initial) * sqrt_k
                pool_token2 = (half / p2_initial) / sqrt_k
                pool_value = (pool_token1 * p1_now) + (pool_token2 * p2_now)

                fee_profit = investment * fee_pct / 100
                pool_value_with_fee = pool_value + fee_profit

                delta_with_fee = hodl_value - pool_value_with_fee
                delta_with_fee_pct = (delta_with_fee / hodl_value) * 100

                # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∫–æ–º–∏—Å—Å–∏—è, —á—Ç–æ–±—ã –ø–æ–∫—Ä—ã—Ç—å IL
                min_fee_dollars = max(hodl_value - pool_value, 0)
                min_fee_pct = (min_fee_dollars / investment) * 100

                # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É–ª–æ–≤ —Å —Ä–∞–∑–Ω—ã–º–∏ –∫–æ–º–∏—Å—Å–∏—è–º–∏
                fee_options = [0.05, 0.3, 1.0]
                fee_table = "\n\ud83d\udcca \u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u0439:\n\u0422\u0438\u043f   \u2502 \u041a\u043e\u043c\u0438\u0441\u0441\u0438\u044f \u2502 \u0414\u043e\u0445\u043e\u0434 \u2502 \u0412\u044b\u0433\u043e\u0434\u043d\u043e?\n" + "-"*35 + "\n"

                recommended_pool = None
                for fee in fee_options:
                    fee_amt = investment * fee / 100
                    total = pool_value + fee_amt
                    diff = total - hodl_value
                    profitable = "\u2705" if diff >= 0 else "\u274c"
                    fee_table += f"{fee:>4.2f}% \u2502 ${fee_amt:>7.2f} \u2502 ${diff:+7.2f} \u2502 {profitable}\n"
                    if recommended_pool is None and diff >= 0:
                        recommended_pool = fee

                if recommended_pool:
                    recommendation = f"\n\ud83d\udccc *\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u044f:* \u041f\u0443\u043b \u0441 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u0435\u0439 {recommended_pool:.2f}% \u043f\u0435\u0440\u0435\u043a\u0440\u044b\u0432\u0430\u0435\u0442 IL \u0438 \u0432\u044b\u0433\u043e\u0434\u0435\u043d \u2705"
                else:
                    recommendation = "\n\ud83d\udccc *\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u044f:* \u041d\u0438 \u043e\u0434\u0438\u043d \u0438\u0437 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0445 \u043f\u0443\u043b\u043e\u0432 \u043d\u0435 \u043f\u0435\u0440\u0435\u043a\u0440\u044b\u0432\u0430\u0435\u0442 IL \u274c"

                response = (
                    "\ud83d\udd89 *Impermanent Loss*\n"
                    "```\n"
                    f"{'\u041c\u043e\u043d\u0435\u0442\u0430':<10}\u2502{'\u0412\u0445\u043e\u0434':>10}\u2502{'\u0412\u044b\u0445\u043e\u0434':>10}\n"
                    f"{'-'*10}\u2502{'-'*10}\u2502{'-'*10}\n"
                    f"{user_state['token1']:<10}\u2502{p1_initial:>10.2f}\u2502{p1_now:>10.2f}\n"
                    f"{user_state['token2']:<10}\u2502{p2_initial:>10.2f}\u2502{p2_now:>10.2f}\n"
                    f"{'-'*33}\n"
                    f"IL: \u2192 \u2192 \u2192 {abs(il)*100:>6.2f}%\n"
                    f"{'-'*33}\n"
                    f"HODL:               ${hodl_value:,.2f}\n"
                    f"\u041f\u0443\u043b \u0431\u0435\u0437 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u0439:   ${pool_value:,.2f}\n"
                    f"\u041a\u043e\u043c\u0438\u0441\u0441\u0438\u0438 ({fee_pct}%): +${fee_profit:,.2f}\n"
                    f"\u041f\u0443\u043b \u0441 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f\u043c\u0438:   ${pool_value_with_fee:,.2f}\n"
                    f"{'-'*33}\n"
                    f"\u0420\u0430\u0437\u043d\u0438\u0446\u0430:            ${delta_with_fee:,.2f} ({delta_with_fee_pct:+.2f}%)\n"
                    "```"
                )

                response += f"\n\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u0430\u044f \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0445\u043e\u0434\u0430 \u0432 0: ~{min_fee_pct:.2f}%"
                response += f"\n{fee_table}"
                response += recommendation

                await update.message.reply_markdown_v2(response)
                user_data_temp[chat_id] = {}
                return await start(update, context)

            except:
                await update.message.reply_text("\u274c \u0412\u0432\u0435\u0434\u0438 \u0447\u0438\u0441\u043b\u043e. \u041f\u0440\u0438\u043c\u0435\u0440: 0.3")
                return IL_FEES

        
async def get_loop_tokens(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        tokens = float(update.message.text.strip())
        user_data_temp[update.effective_chat.id] = {'tokens': tokens}
        await update.message.reply_text("üìä –í–≤–µ–¥–∏ LTV (–≤ %):")
        return LOOP_LTV
    except ValueError:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ. –ü—Ä–∏–º–µ—Ä: 10")
        return LOOP_TOKENS

async def get_loop_ltv(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        ltv = float(update.message.text.strip().replace('%', '')) / 100
        user_data_temp[update.effective_chat.id]['ltv'] = ltv
        await update.message.reply_text("üìà –í–≤–µ–¥–∏ –ø—Ä–æ—Ü–µ–Ω—Ç –ø–æ –¥–µ–ø–æ–∑–∏—Ç—É (–≤ %):")
        return LOOP_SUPPLY
    except ValueError:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ. –ü—Ä–∏–º–µ—Ä: 70")
        return LOOP_LTV

async def get_loop_supply(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        supply = float(update.message.text.strip().replace('%', ''))
        user_data_temp[update.effective_chat.id]['supply'] = supply
        await update.message.reply_text("üí∏ –í–≤–µ–¥–∏ –ø—Ä–æ—Ü–µ–Ω—Ç –ø–æ –∑–∞–π–º—É (–≤ %):")
        return LOOP_BORROW
    except ValueError:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ. –ü—Ä–∏–º–µ—Ä: 15")
        return LOOP_SUPPLY

async def get_loop_borrow(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        borrow = float(update.message.text.strip().replace('%', ''))
        data = user_data_temp[update.effective_chat.id]

        rounds = calculate_looping_table(
            tokens=data['tokens'],
            ltv=data['ltv'],
            supply_rate=data['supply'],
            borrow_rate=borrow
        )

        response = "üîÅ *–õ—É–ø–∏–Ω–≥ (10 –∫—Ä—É–≥–æ–≤)*\n"
        response += "```\n"
        response += "–ö—Ä—É–≥ |   –î–µ–ø–æ–∑–∏—Ç  |   –ó–∞—ë–º   |   –î–æ–ª–≥   |   APY\n"
        response += "-----|------------|----------|----------|--------\n"

        for r in rounds:
            response += f"{r['round']:>4} | {r['deposit']:>10.2f} | {r['borrow']:>8.2f} | {r['total_borrow']:>8.2f} | {r['apy']:>6.2f}%\n"

        response += "```"

        await update.message.reply_text(response, parse_mode='Markdown')
        
        return await start(update, context)

    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {e}")
        return LOOP_BORROW
        
async def get_loan_dep_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        amount = float(update.message.text.strip())
        user_data_temp[update.effective_chat.id] = {'dep_amount': amount}
        await update.message.reply_text("üíµ –í–≤–µ–¥–∏ —Ü–µ–Ω—É —Ç–æ–∫–µ–Ω–∞ –¥–µ–ø–æ–∑–∏—Ç–∞:")
        return LOAN_DEP_PRICE
    except:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return LOAN_DEP_AMOUNT

async def get_loan_dep_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        price = float(update.message.text.strip())
        user_data_temp[update.effective_chat.id]['dep_price'] = price
        await update.message.reply_text("üí∏ –í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –∑–∞–π–º–µ:")
        return LOAN_BORROW_AMOUNT
    except:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return LOAN_DEP_PRICE

async def get_loan_borrow_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        amount = float(update.message.text.strip())
        user_data_temp[update.effective_chat.id]['borrow_amount'] = amount
        await update.message.reply_text("üí≤ –í–≤–µ–¥–∏ —Ü–µ–Ω—É —Ç–æ–∫–µ–Ω–∞ –∑–∞–π–º–∞:")
        return LOAN_BORROW_PRICE
    except:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return LOAN_BORROW_AMOUNT

async def get_loan_borrow_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        price = float(update.message.text.strip())
        user_data_temp[update.effective_chat.id]['borrow_price'] = price
        await update.message.reply_text("üìä –í–≤–µ–¥–∏ LTV (–Ω–∞–ø—Ä–∏–º–µ—Ä: 0.8):")
        return LOAN_LTV
    except:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return LOAN_BORROW_PRICE

async def get_loan_ltv(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        ltv_input = float(update.message.text.strip().replace('%', ''))
        if ltv_input > 1:
            ltv_input /= 100  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º 70% -> 0.7
        user_data_temp[update.effective_chat.id]['ltv'] = ltv_input
        await update.message.reply_text("üßÆ –í–≤–µ–¥–∏ borrow factor (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1):")
        return LOAN_BORROW_FACTOR
    except:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return LOAN_LTV
async def get_loan_borrow_factor(update: Update, context: ContextTypes.DEFAULT_TYPE):
            try:
                factor = float(update.message.text.strip())
                data = user_data_temp[update.effective_chat.id]
                dep_value = data['dep_amount'] * data['dep_price']
                borrow_value = data['borrow_amount'] * data['borrow_price']

                hf = (data['ltv'] * dep_value) / (borrow_value * factor)
                rf = 1 / hf if hf != 0 else 0
                liquidation_price_dep = data['dep_price'] / hf if hf != 0 else 0
                liquidation_price_borrow = data['borrow_price'] / hf if hf != 0 else 0

                response = (
                    "üí≥ *–ö—Ä–µ–¥–∏—Ç–æ–≤–∞–Ω–∏–µ*\n"
                    "```\n"
                    f"Health Factor:         {hf:.2f}\n"
                    f"Risk Factor:           {rf:.1%}\n"
                    f"–õ–∏–∫–≤. —Ü–µ–Ω–∞ –¥–µ–ø–æ–∑–∏—Ç–∞:   ${liquidation_price_dep:.4f}\n"
                    f"–õ–∏–∫–≤. —Ü–µ–Ω–∞ –∑–∞–π–º–∞:      ${liquidation_price_borrow:.4f}\n"
                    "```\n"
                )

                await update.message.reply_text(response, parse_mode='Markdown')
                return await start(update, context)

            except:
                await update.message.reply_text("‚ùå –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫.")
                return LOAN_BORROW_FACTOR

async def get_il_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    text = update.message.text.strip().replace(',', '.')
    user_state = user_data_temp.setdefault(chat_id, {})

    try:
        if 'token1' not in user_state:
            user_state['token1'] = text.upper()
            await update.message.reply_text(f"üí∞ –í–≤–µ–¥–∏ —Ü–µ–Ω—É {user_state['token1']} –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ –ø—É–ª:")
            return IL_INPUT

        elif 'p1_initial' not in user_state:
            user_state['p1_initial'] = float(text)
            await update.message.reply_text(f"üìâ –í–≤–µ–¥–∏ —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É {user_state['token1']}:")
            return IL_INPUT

        elif 'p1_now' not in user_state:
            user_state['p1_now'] = float(text)
            await update.message.reply_text("üî† –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–π –º–æ–Ω–µ—Ç—ã:")
            return IL_INPUT

        elif 'token2' not in user_state:
            user_state['token2'] = text.upper()
            await update.message.reply_text(f"üí∞ –í–≤–µ–¥–∏ —Ü–µ–Ω—É {user_state['token2']} –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ –ø—É–ª:")
            return IL_INPUT

        elif 'p2_initial' not in user_state:
            user_state['p2_initial'] = float(text)
            await update.message.reply_text(f"üìâ –í–≤–µ–¥–∏ —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É {user_state['token2']}:")
            return IL_INPUT

        elif 'p2_now' not in user_state:
            user_state['p2_now'] = float(text)
            await update.message.reply_text("üíµ –°–∫–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ —Ç—ã –∑–∞—Ä–∞–±–æ—Ç–∞–ª –Ω–∞ –∫–æ–º–∏—Å—Å–∏—è—Ö? (–Ω–∞–ø—Ä–∏–º–µ—Ä: 0.5)")
            return IL_FEES

        else:
            user_data_temp[chat_id] = {}
            await update.message.reply_text("‚ùå –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ù–∞—á–Ω—ë–º –∑–∞–Ω–æ–≤–æ. –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–π –º–æ–Ω–µ—Ç—ã:")
            return IL_INPUT

    except Exception:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞.")
        return IL_INPUT
async def get_rate(update: Update, context: ContextTypes.DEFAULT_TYPE):
           try:
               rate = float(update.message.text.strip().replace('%', ''))
               user_data_temp[update.effective_chat.id] = {'rate': rate}
               await update.message.reply_text("‚è± –¢–µ–ø–µ—Ä—å –Ω–∞–ø–∏—à–∏, —Ä–∞–∑ –≤ —Å–∫–æ–ª—å–∫–æ —á–∞—Å–æ–≤ –Ω–∞—á–∏—Å–ª—è–µ—Ç—Å—è –ø—Ä–æ—Ü–µ–Ω—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä: 4)")
               return HOURS
           except ValueError:
               await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ —á–∏—Å–ª–æ. –ù–∞–ø—Ä–∏–º–µ—Ä: 0.5")
               return RATE

async def get_hours(update: Update, context: ContextTypes.DEFAULT_TYPE):
           try:
               hours = float(update.message.text.strip().replace('—á', '').replace(' ', ''))
               rate = user_data_temp[update.effective_chat.id]['rate']
               simple = calculate_simple(rate, hours)

               response = (
                   "*üìà –†–∞—Å—á—ë—Ç —Ñ–∞–Ω–¥–∏–Ω–≥–∞*\n"
                   "```\n"
                   f"{'–°—Ç–∞–≤–∫–∞ —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è:':<22} {rate}%\n"
                   f"{'–ù–∞—á–∏—Å–ª—è–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ:':<22} {hours} —á\n"
                   f"{'APR:':<22} {simple:.2f}%\n"
                   "```"
               )

               await update.message.reply_markdown_v2(response)
               return await start(update, context)

           except Exception:
               await update.message.reply_text("‚ùå –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
               return RATE
               
from telegram.ext import CallbackQueryHandler

async def choose_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "back":
        return await start(update, context)

    choice = query.data

    if choice == "rate":
        await query.edit_message_text(
            "üí¨ –í–≤–µ–¥–∏ –ø—Ä–æ—Ü–µ–Ω—Ç —Å—Ç–∞–≤–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 0.5):",
            reply_markup=back_to_menu_button()
        )
        return RATE

    elif choice == "looping":
        await query.edit_message_text(
            "üî¢ –í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤:",
            reply_markup=back_to_menu_button()
        )
        return LOOP_TOKENS

    elif choice == "loan":
        await query.edit_message_text(
            "üí∞ –í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –¥–µ–ø–æ–∑–∏—Ç–µ:",
            reply_markup=back_to_menu_button()
        )
        return LOAN_DEP_AMOUNT

    elif choice == "il":
        await query.edit_message_text(
            "üî† –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–π –º–æ–Ω–µ—Ç—ã:",
            reply_markup=back_to_menu_button()
        )
        user_data_temp[query.from_user.id] = {}  # <-- –æ—á–∏—â–∞–µ–º
        return IL_INPUT

    else:
        await query.edit_message_text("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
        return CHOOSING
        
# --- –•–µ–Ω–¥–ª–µ—Ä —Å–æ—Å—Ç–æ—è–Ω–∏–π ---
conv_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(choose_option)],
    states={
        CHOOSING: [CallbackQueryHandler(choose_option)],
        RATE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_rate),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        HOURS: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_hours),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOOP_TOKENS: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loop_tokens),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOOP_LTV: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loop_ltv),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOOP_SUPPLY: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loop_supply),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOOP_BORROW: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loop_borrow),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOAN_DEP_AMOUNT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loan_dep_amount),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOAN_DEP_PRICE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loan_dep_price),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOAN_BORROW_AMOUNT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loan_borrow_amount),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOAN_BORROW_PRICE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loan_borrow_price),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOAN_LTV: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loan_ltv),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        LOAN_BORROW_FACTOR: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_loan_borrow_factor),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        IL_INPUT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_il_input),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
        IL_FEES: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_il_fees),
            CallbackQueryHandler(choose_option, pattern="^back$")
        ],
    },
    fallbacks=[]
)

# --- –ó–∞–ø—É—Å–∫ ---
if __name__ == "__main__":
    keep_alive()
    app = ApplicationBuilder().token(os.getenv("BOT_TOKEN")).build()

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, start))

    app.run_polling()
